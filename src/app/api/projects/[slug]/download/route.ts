import { NextRequest, NextResponse } from 'next/server';
import { getProjectMetadata, listArtifacts, readArtifact } from '@/app/api/lib/project-utils';
import archiver from 'archiver';
import { withAuth, type AuthSession } from '@/app/api/middleware/auth-guard';
import { logger } from '@/lib/logger';

export const runtime = 'nodejs';

export const GET = withAuth(
  async (
    _request: NextRequest,
    { params }: { params: Promise<{ slug: string }> },
    session: AuthSession
  ): Promise<Response> => {
    try {
      const { slug } = await params;

      const metadata = await getProjectMetadata(slug, session.user.id);

      if (!metadata || metadata.created_by_id !== session.user.id) {
        return NextResponse.json(
          { success: false, error: 'Project not found' },
          { status: 404 }
        );
      }

      // Only allow download in DONE phase
      if (metadata.current_phase !== 'DONE') {
        return NextResponse.json(
          {
            success: false,
            error: `Cannot download incomplete project. Current phase: ${metadata.current_phase}`
          },
          { status: 400 }
        );
      }

      // Verify HANDOFF.md exists
      const doneArtifacts = await listArtifacts(slug, 'DONE');
      const hasHandoff = doneArtifacts.some((a: { name: string }) => a.name === 'HANDOFF.md');

      if (!hasHandoff) {
        return NextResponse.json(
          {
            success: false,
            error: 'HANDOFF.md not generated. Call /generate-handoff endpoint first.'
          },
          { status: 400 }
        );
      }

      // Create ZIP archive in memory
      const chunks: Buffer[] = [];

      return new Promise<Response>(async (resolve) => {
        const archive = archiver('zip', {
          zlib: { level: 9 }
        });

      // Collect data
      archive.on('data', (chunk: Buffer) => {
        chunks.push(chunk);
      });

      archive.on('end', () => {
        const zipBuffer = Buffer.concat(chunks);

        // Use project title for filename, fallback to slug if empty
        const filename = metadata.name || slug;
        // Sanitize filename (remove/replace special characters)
        const sanitizedFilename = filename
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '');
        const zipFilename = `${sanitizedFilename}-specs.zip`;

        resolve(
          new NextResponse(zipBuffer, {
            status: 200,
            headers: {
              'Content-Type': 'application/zip',
              'Content-Disposition': `attachment; filename="${zipFilename}"`,
              'Content-Length': zipBuffer.length.toString()
            }
          })
        );
      });

      archive.on('error', (error: Error) => {
        logger.error('Archive error:', error);
        resolve(
          NextResponse.json(
            {
              success: false,
              error: `Failed to create ZIP: ${error.message}`
            },
            { status: 500 }
          )
        );
      });

      // Add all artifacts from all phases
      const allPhases = ['ANALYSIS', 'STACK_SELECTION', 'SPEC', 'DEPENDENCIES', 'SOLUTIONING', 'VALIDATE', 'DONE'];

      for (const phase of allPhases) {
        const artifacts = await listArtifacts(slug, phase);
        for (const artifact of artifacts) {
          try {
            // Read from R2 or filesystem; falls back to DB in project-utils
            const content = await readArtifact(slug, phase, artifact.name);
            archive.append(content, { name: `${slug}/specs/${phase}/${artifact.name}` });
          } catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            logger.error(`Warning: Failed to read artifact ${artifact.name}:`, error);
            // Continue with empty content rather than failing entire ZIP
            archive.append('', { name: `${slug}/specs/${phase}/${artifact.name}` });
          }
        }
      }

      // Add metadata file
      const metadataContent = JSON.stringify(
        {
          name: metadata.name,
          description: metadata.description,
          slug: metadata.slug,
          created_at: metadata.created_at,
          completed_at: new Date().toISOString(),
          stack_choice: metadata.stack_choice,
          phases_completed: metadata.phases_completed
        },
        null,
        2
      );
      archive.append(metadataContent, { name: `${slug}/metadata.json` });

      // Add README
      const readmeContent = `# ${metadata.name || 'Project Specifications'}

## Overview
This ZIP archive contains complete project specifications generated by the Spec-Driven Platform.

## Contents

### Specifications
- \`ANALYSIS/\` - Initial requirements gathering (constitution, brief, personas)
- \`STACK_SELECTION/\` - Technology stack decisions
- \`SPEC/\` - Detailed specifications (PRD, data model, API spec)
- \`DEPENDENCIES/\` - Project dependencies and requirements
- \`SOLUTIONING/\` - Architecture, epics, and task breakdown
- \`DONE/\` - HANDOFF.md with complete LLM generation prompt

### Files
- \`metadata.json\` - Project metadata
- \`README.md\` - This file

## Using This Package

1. **Review** - Read through all specifications in order
2. **Extract** - Unzip to your project folder
3. **Generate** - Use HANDOFF.md with your preferred LLM for code generation
4. **Customize** - Modify as needed for your specific requirements
5. **Implement** - Start coding based on the generated guidance

## Questions?

For more information about the Spec-Driven Platform, refer to:
- HANDOFF.md - Complete generation prompt
- Individual specification files for detailed guidance

---
Generated: ${new Date().toISOString()}
Project: ${metadata.name}
`;
      archive.append(readmeContent, { name: `${slug}/README.md` });

        archive.finalize();
      });
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      logger.error('Error creating download:', err);
      return NextResponse.json(
        {
          success: false,
          error: `Failed to create download: ${err.message}`
        },
        { status: 500 }
      );
    }
  }
);
