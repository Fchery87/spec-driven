// Spec-Driven Platform Prisma Schema
// Database: Neon PostgreSQL (https://neon.tech)
// To set up: npm run db:push (or npx prisma db push)
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Uses PostgreSQL for both development and production
  // Connection string format: postgresql://[user]:[password]@[host]/[database]
}

// Project model
model Project {
  id                    String      @id @default(cuid())
  slug                  String      @unique
  name                  String
  description           String?
  current_phase         String      @default("ANALYSIS")
  phases_completed      String      @default("") // Comma-separated list
  stack_choice          String?
  stack_approved        Boolean     @default(false)
  dependencies_approved Boolean     @default(false)
  handoff_generated     Boolean     @default(false)

  // Timestamps
  created_at            DateTime    @default(now())
  updated_at            DateTime    @updatedAt
  handoff_generated_at  DateTime?

  // Relations
  artifacts             Artifact[]
  phase_history         PhaseHistory[]

  @@index([slug])
  @@index([created_at])
}

// Artifact model - stores generated specifications
model Artifact {
  id          String   @id @default(cuid())
  project_id  String
  phase       String   // ANALYSIS, STACK_SELECTION, SPEC, DEPENDENCIES, SOLUTIONING, DONE
  filename    String
  content     String   @db.Text
  version     Int      @default(1)
  file_hash   String?  // For detecting duplicates/changes

  // Timestamps
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  project     Project  @relation(fields: [project_id], references: [id], onDelete: Cascade)

  @@unique([project_id, phase, filename, version])
  @@index([project_id])
  @@index([phase])
  @@index([created_at])
}

// Phase history - tracks when phases were completed
model PhaseHistory {
  id             String   @id @default(cuid())
  project_id     String
  phase          String
  status         String   @default("in_progress") // in_progress, completed, failed
  started_at     DateTime @default(now())
  completed_at   DateTime?
  duration_ms    Int?     // Time spent in this phase
  error_message  String?  // If phase failed

  // Relations
  project        Project  @relation(fields: [project_id], references: [id], onDelete: Cascade)

  @@index([project_id])
  @@index([phase])
}

// Stack choice record - for audit trail
model StackChoice {
  id            String   @id @default(cuid())
  project_id    String   @unique
  stack_id      String
  reasoning     String   @db.Text
  approved_at   DateTime @default(now())

  @@index([project_id])
}

// Dependency approval record
model DependencyApproval {
  id              String   @id @default(cuid())
  project_id      String   @unique
  approved_at     DateTime @default(now())
  approved_by     String?  // For future multi-user support
  notes           String?  @db.Text

  @@index([project_id])
}

// User model (for future multi-user support)
model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?
  emailVerified  Boolean  @default(false)
  image          String?
  password_hash  String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Better Auth relations
  accounts       Account[]
  sessions       Session[]
  verifications  Verification[]

  @@index([email])
}

// Better Auth: Account model (OAuth/credentials)
model Account {
  id                 String   @id @default(cuid())
  userId             String
  accountId          String
  providerId         String
  password           String?  @db.Text
  accessToken        String?  @db.Text
  refreshToken       String?  @db.Text
  expiresAt          Int?
  tokenType          String?
  scope              String?
  idToken            String?  @db.Text
  sessionState       String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([accountId, providerId])
  @@index([userId])
}

// Better Auth: Session model
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Better Auth: Verification token model (for email verification, password reset)
model Verification {
  id        String   @id @default(cuid())
  identifier String
  value     String
  expiresAt DateTime
  userId    String?

  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([identifier, value])
  @@index([userId])
}

// Settings model for app-wide configuration
model Setting {
  key       String  @id
  value     String  @db.Text
  updated_at DateTime @updatedAt
}
