// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { Project } from '@/types/orchestrator';
import { listArtifacts } from '@/app/api/lib/project-utils';
import { logger } from '@/lib/logger';
import { readFileSync, existsSync } from 'fs';
import { resolve } from 'path';

/**
 * Generate HANDOFF.md and README.md for LLM-based code generation
 */
export class HandoffGenerator {
  /**
   * Generate README.md - a quick-start guide for the project
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async generateReadme(
    slug: string,
    projectMetadata: Record<string, any>,
    artifacts: Record<string, string>
  ): Promise<string> {
    const stackChoice = projectMetadata.stack_choice || 'custom';
    const name = projectMetadata.name || 'Unnamed Project';
    const description = projectMetadata.description || '';

    // Extract key info from artifacts
    const projectBrief = artifacts['ANALYSIS/project-brief.md'] || '';
    const architecture = artifacts['SOLUTIONING/architecture.md'] || '';

    // Try to extract executive summary from project brief
    let executiveSummary = '';
    const summaryMatch = projectBrief.match(
      /##?\s*Executive Summary[\s\S]*?(?=##|\n\n\n|$)/i
    );
    if (summaryMatch) {
      executiveSummary = summaryMatch[0]
        .replace(/##?\s*Executive Summary\s*/i, '')
        .trim()
        .slice(0, 500);
    } else {
      executiveSummary =
        description || 'A project generated by Spec-Driven Platform.';
    }

    // Extract tech stack info
    const stackDescriptions: Record<string, string> = {
      web_application: 'Web Application (Monolithic Full-Stack)',
      mobile_application: 'Mobile Application (Cross-Platform Native)',
      api_first_platform: 'API-First Platform (Headless/Multi-Client)',
      // Legacy support
      nextjs_only_expo: 'Next.js 14 + Expo (React Native)',
      hybrid_nextjs_fastapi_expo: 'Next.js 14 + FastAPI + Expo',
      monolithic_fullstack: 'Web Application (Monolithic Full-Stack)',
      decoupled_services: 'API-First Platform (Headless/Multi-Client)',
    };
    const techStack = stackDescriptions[stackChoice] || stackChoice;

    return `# ${name}

${executiveSummary}

## Tech Stack

- **Stack**: ${techStack}
- **Generated**: ${new Date().toISOString().split('T')[0]}

## Quick Start

\`\`\`bash
# Clone or download the project
git clone <repository-url>
cd ${slug}

# Install dependencies
pnpm install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your values

# Run database migrations (if applicable)
pnpm db:migrate

# Start development server
pnpm dev
\`\`\`

## Project Structure

\`\`\`
${slug}/
├── HANDOFF.md          # Complete project handoff for LLM code generation
├── README.md           # This file
├── specs/              # All specification documents
│   ├── ANALYSIS/       # Analysis phase outputs (constitution, brief, classification, personas)
│   ├── STACK_SELECTION/# Technology stack decisions
│   ├── SPEC/           # PRD, data models, API specs, design system
│   ├── DEPENDENCIES/   # Dependency definitions with security notes
│   ├── SOLUTIONING/    # Architecture, epics, and task breakdown
│   └── VALIDATE/       # Validation report and coverage matrix
└── (generated code)    # Use HANDOFF.md with an LLM to generate
\`\`\`

## Documentation

| Document | Description |
|----------|-------------|
| [HANDOFF.md](./HANDOFF.md) | Complete handoff document for LLM code generation |
| [constitution.md](./specs/ANALYSIS/constitution.md) | Project guiding principles |
| [project-brief.md](./specs/ANALYSIS/project-brief.md) | Project overview and requirements |
| [project-classification.json](./specs/ANALYSIS/project-classification.json) | Machine-readable project classification |
| [stack-analysis.md](./specs/STACK_SELECTION/stack-analysis.md) | Stack recommendation summary |
| [stack-decision.md](./specs/STACK_SELECTION/stack-decision.md) | Approved technology stack selection |
| [stack.json](./specs/STACK_SELECTION/stack.json) | Machine-readable stack contract |
| [PRD.md](./specs/SPEC/PRD.md) | Product Requirements Document |
| [DEPENDENCIES.md](./specs/DEPENDENCIES/DEPENDENCIES.md) | Dependency rationale and grouping |
| [dependencies.json](./specs/DEPENDENCIES/dependencies.json) | Machine-readable dependencies contract |
| [design-system.md](./specs/SPEC/design-system.md) | Design tokens and UI guidelines |
| [component-inventory.md](./specs/SPEC/component-inventory.md) | UI component specifications |
| [user-flows.md](./specs/SPEC/user-flows.md) | User journey definitions |
| [architecture.md](./specs/SOLUTIONING/architecture.md) | System architecture |
| [tasks.md](./specs/SOLUTIONING/tasks.md) | Implementation tasks (test-first, with [P] parallelism markers) |
| [validation-report.md](./specs/VALIDATE/validation-report.md) | Cross-artifact consistency check results |
| [coverage-matrix.md](./specs/VALIDATE/coverage-matrix.md) | Artifact coverage by phase |

## Code Generation

To generate the implementation code, use the HANDOFF.md with your preferred LLM:

1. Open HANDOFF.md in your editor
2. Copy the entire content
3. Paste into Claude, GPT-4, or Gemini
4. Request code generation following the specifications

## License

This project was generated using the Spec-Driven Platform.

---

*Generated by [Spec-Driven Platform](https://spec-driven.dev)*
`;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async generateHandoff(
    slug: string,
    projectMetadata: Record<string, any>
  ): Promise<string> {
    const stackChoice = projectMetadata.stack_choice || 'custom';
    const name = projectMetadata.name || 'Unnamed Project';

    // Collect artifacts from all completed phases (7-phase workflow v3.0)
    const allPhases = [
      'ANALYSIS',
      'STACK_SELECTION',
      'SPEC',
      'DEPENDENCIES',
      'SOLUTIONING',
      'VALIDATE',
    ];
    const artifacts: Record<string, string> = {};

    for (const phase of allPhases) {
      const phaseArtifacts = await listArtifacts(slug, phase);
      for (const artifact of phaseArtifacts) {
        try {
          const artifactPath = resolve(
            process.cwd(),
            'projects',
            slug,
            'specs',
            phase,
            'v1',
            artifact.name
          );
          if (existsSync(artifactPath)) {
            const content = readFileSync(artifactPath, 'utf8');
            artifacts[`${phase}/${artifact.name}`] = content;
          } else {
            artifacts[`${phase}/${artifact.name}`] = '';
          }
        } catch (error) {
          const err = error instanceof Error ? error : new Error(String(error));
          logger.warn(
            `Failed to read artifact ${artifact.name}: ${err.message}`,
            {
              errorName: err.name,
              stack: err.stack,
            }
          );
          artifacts[`${phase}/${artifact.name}`] = '';
        }
      }
    }

    // Generate markdown handoff document
    const handoff = `# ${name} - Project Handoff

## Overview
This is an auto-generated handoff document containing all project specifications, architecture decisions, and implementation guidance generated by the Spec-Driven Platform (v3.0).

**Generated:** ${new Date().toISOString()}
**Stack Choice:** ${stackChoice}
**Project Slug:** ${slug}
**Platform Version:** 3.0

---

## Constitutional Articles (Governing Principles)

All specifications in this handoff adhere to five constitutional articles:

1. **Library-First Principle** - Every feature begins as a reusable module with clear boundaries
2. **Test-First Imperative (NON-NEGOTIABLE)** - No implementation code before tests are specified
3. **Simplicity Gate** - Maximum 3 services for MVP; additional complexity requires justification
4. **Anti-Abstraction** - Use frameworks directly; no unnecessary wrappers
5. **Integration-First Testing** - Prefer real databases over mocks in tests

---

## Reading Order

This document should be read in the following order for best understanding:

### Phase 1: Project Foundation (ANALYSIS)
1. **constitution.md** - Project philosophy and guiding principles
2. **project-brief.md** - High-level overview and context
3. **project-classification.json** - Machine-readable project classification
4. **personas.md** - User personas and target audience

> **Note:** Any \`[AI ASSUMED: assumption - rationale]\` markers indicate AI-generated assumptions. Review these carefully.

### Phase 2: Stack Decision (STACK_SELECTION)
4. **stack-analysis.md** - Recommendation summary
5. **stack-decision.md** - Approved technology stack and composition
6. **stack-rationale.md** - Why this stack was selected, alternatives considered
7. **stack.json** - Canonical machine-readable stack contract

### Phase 3: Specifications (SPEC)
6. **PRD.md** - Product requirements and features
7. **data-model.md** - Database schema and data structures
8. **api-spec.json** - API endpoints and contracts
9. **design-system.md** - Colors, typography, spacing, motion tokens (follow fire-your-design-team.md principles)
10. **component-inventory.md** - UI components mapped to shadcn/ui
11. **user-flows.md** - Key user journeys and interactions

### Phase 4: Dependencies (DEPENDENCIES)
12. **DEPENDENCIES.md** - Dependency rationale (human-readable)
13. **dependencies.json** - Canonical machine-readable dependencies contract

### Phase 5: Implementation Plan (SOLUTIONING)
13. **architecture.md** - System architecture and design patterns
14. **epics.md** - Feature epics and logical groupings
15. **tasks.md** - Detailed implementation tasks with dependencies and parallelism markers

> **Note:** Tasks marked with \`[P]\` can be executed in parallel.

### Phase 6: Validation (VALIDATE)
16. **validation-report.md** - Cross-artifact consistency check results
17. **coverage-matrix.md** - Artifact coverage by phase

---

## Project Context

### Artifact Manifest

\`\`\`
${Object.keys(artifacts)
  .map((name) => `- ${name}`)
  .join('\n')}
\`\`\`

---

## LLM Code Generation Prompt

Use the following prompt with your preferred LLM (Claude, GPT-4, Gemini, etc.) to generate production-ready code:

\`\`\`
You are an expert full-stack software engineer tasked with implementing a complete project based on comprehensive specifications.

**Project Name:** ${name}
**Technology Stack:** ${stackChoice}
**Spec-Driven Platform Version:** 3.0

Please review the attached specifications in the order listed above, then:

1. **Understand the requirements** - Read through all specification documents
2. **Validate consistency** - Ensure all documents are consistent and complete
3. **Plan delivery in milestones** - Do NOT attempt the entire codebase in a single response
4. **Generate scaffolding first** - Project skeleton, config, and test harness before features
5. **Implement incrementally** - Follow \`tasks.md\` in order; implement 3–5 tasks per milestone
6. **Test-First (MANDATORY)** - Write tests BEFORE implementation code
7. **Run and fix** - After each milestone, run relevant tests and fix failures before proceeding
8. **Document efficiently** - Prefer high-quality READMEs and minimal essential comments (avoid comment-noise)

**Constitutional Articles (MUST FOLLOW):**
1. **Library-First** - Build features as reusable modules with clear boundaries
2. **Test-First** - Write test specifications before any implementation (Gherkin-style acceptance criteria)
3. **Simplicity Gate** - Max 3 services for MVP; justify additional complexity
4. **Anti-Abstraction** - Use frameworks directly; avoid unnecessary wrapper layers
5. **Integration-First Testing** - Use real databases in tests, not mocks

**Test Implementation Order:**
1. Contract tests (API schema validation)
2. Integration tests (real database, real services)
3. E2E tests (critical user journeys)
4. Unit tests (pure functions, edge cases)

**Key constraints:**
- Follow the exact architecture described in architecture.md
- Implement all API endpoints in api-spec
- Include all database tables from data-model
- Satisfy all requirements in PRD.md
- Use the specified technology stack from stack.json (and stack-decision.md for narrative)
- Follow security baseline requirements
- **Tasks with [P] markers** can be implemented in parallel
- **Review [AI ASSUMED] markers** - verify AI assumptions are acceptable
- **Design System**: Implement UI following design-system.md exactly:
  - Use ONLY the 4 typography sizes defined (body, label, heading, display)
  - Use ONLY 8pt grid spacing values (8, 16, 24, 32, 48, 64)
  - Follow the 60/30/10 color rule with project-specific colors
  - Use Framer Motion with the defined duration scale for animations
  - Use shadcn/ui components as specified in component-inventory.md
  - Implement user journeys exactly as defined in user-flows.md
  - AVOID: purple defaults, gradient blobs, Inter font, excessive border radius

**Output:**
Work milestone-by-milestone. For each milestone:
1. List the tasks being implemented (TASK IDs + REQ IDs)
2. Provide code changes as file outputs (prefer unified diffs or \`filename:\` blocks)
3. Provide the exact commands to run tests/lint/build
4. Summarize what’s done and what’s next

If context limits prevent reading all documents, ask for ONLY the next required artifact section(s). Do not guess.
\`\`\`

---

## Specification Documents

### Constitution

\`\`\`markdown
${
  artifacts['ANALYSIS/constitution.md'] || 'Constitution document not available'
}
\`\`\`

### Project Brief

\`\`\`markdown
${
  artifacts['ANALYSIS/project-brief.md'] ||
  'Project brief document not available'
}
\`\`\`

### Personas

\`\`\`markdown
${artifacts['ANALYSIS/personas.md'] || 'Personas document not available'}
\`\`\`

---

## Stack Selection

### Stack Proposal

\`\`\`markdown
${
  artifacts['STACK_SELECTION/stack-analysis.md'] ||
  'Stack proposal document not available'
}
\`\`\`

### Stack Decision

\`\`\`markdown
${
  artifacts['STACK_SELECTION/stack-decision.md'] ||
  'Stack decision document not available'
}
\`\`\`

### Stack Rationale

\`\`\`markdown
${
  artifacts['STACK_SELECTION/stack-rationale.md'] ||
  'Stack rationale document not available'
}
\`\`\`

### Stack Contract (stack.json)

\`\`\`json
${artifacts['STACK_SELECTION/stack.json'] || 'stack.json not available'}
\`\`\`

---

## Specifications

### Product Requirements Document (PRD)

\`\`\`markdown
${artifacts['SPEC/PRD.md'] || 'PRD document not available'}
\`\`\`

### Data Model

\`\`\`markdown
${artifacts['SPEC/data-model.md'] || 'Data model document not available'}
\`\`\`

### API Specification

\`\`\`json
${
  artifacts['SPEC/api-spec.json'] ||
  artifacts['SPEC/api-spec.md'] ||
  'API specification not available'
}
\`\`\`

### Design System

\`\`\`markdown
${artifacts['SPEC/design-system.md'] || 'Design system document not available'}
\`\`\`

### Component Inventory

\`\`\`markdown
${
  artifacts['SPEC/component-inventory.md'] ||
  'Component inventory document not available'
}
\`\`\`

### User Flows

\`\`\`markdown
${artifacts['SPEC/user-flows.md'] || 'User flows document not available'}
\`\`\`

---

## Dependencies

### Dependencies

\`\`\`markdown
${
  artifacts['DEPENDENCIES/DEPENDENCIES.md'] ||
  'Dependencies document not available'
}
\`\`\`

### Dependencies Contract (dependencies.json)

\`\`\`json
${
  artifacts['DEPENDENCIES/dependencies.json'] ||
  'dependencies.json not available'
}
\`\`\`

### Architecture

\`\`\`markdown
${
  artifacts['SOLUTIONING/architecture.md'] ||
  'Architecture document not available'
}
\`\`\`

### Epics

\`\`\`markdown
${artifacts['SOLUTIONING/epics.md'] || 'Epics document not available'}
\`\`\`

### Tasks

\`\`\`markdown
${artifacts['SOLUTIONING/tasks.md'] || 'Tasks document not available'}
\`\`\`

---

## Validation Results

### Validation Report

\`\`\`markdown
${
  artifacts['VALIDATE/validation-report.md'] ||
  'Validation report not available (project may not have completed VALIDATE phase)'
}
\`\`\`

### Coverage Matrix

\`\`\`markdown
${
  artifacts['VALIDATE/coverage-matrix.md'] ||
  'Coverage matrix not available (project may not have completed VALIDATE phase)'
}
\`\`\`

---

## Next Steps

1. **Download** - Download the complete ZIP archive containing all specification files
2. **Review** - Study the specifications thoroughly
3. **Generate** - Use this HANDOFF.md with your preferred LLM to generate code
4. **Customize** - Modify generated code as needed for your specific requirements
5. **Test** - Write comprehensive tests for all functionality
6. **Deploy** - Follow deployment guidelines in architecture.md

---

## Support & Questions

For questions about the specifications or the Spec-Driven Platform:
- Review the CLAUDE.md file in the original project
- Check the ORCHESTRATOR_DESIGN.md for detailed workflow information
- Refer to individual specification documents for detailed guidance

Generated by **Spec-Driven Platform** - Transform ideas into production-ready projects.
`;

    return handoff;
  }
}
